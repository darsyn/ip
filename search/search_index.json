{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Introduction","text":"<p>IP is an immutable value object for (both version 4 and 6) IP addresses. Several helper methods are provided for ranges, broadcast and network addresses, subnet masks, whether an IP is a certain type (defined by RFC's), etc.</p> <p>Internally, the library converts IP addresses to a binary sequence for easy mathematical operations and consistency. You can choose to work with IPv6 addresses as 16-byte binary sequences, IPv4 addresses as 4-byte binary sequences, or work with both interchangeably by representing IPv4 addresses as 16-byte binary sequences (which is recommended for most applications).</p>"},{"location":"index.html#license","title":"License","text":"<p>Please see the separate license file included in this repository for a full copy of the MIT license, which this project is licensed under.</p>"},{"location":"index.html#authors","title":"Authors","text":"<ul> <li>Zan Baldwin</li> <li>Jaume Casado Ruiz</li> <li>Pascal Hofmann</li> </ul> <p>If you make a contribution (submit a pull request), don't forget to add your name here!</p>"},{"location":"02-installation.html","title":"Installation","text":""},{"location":"02-installation.html#system-requirements","title":"System Requirements","text":"<ul> <li>All functionality can be implemented without using new language features, so   this library will support PHP versions <code>5.6</code> onwards.</li> <li>This library cannot be used on 32-bits systems due to a dependency on the   in-built PHP functions <code>inet_pton</code> and <code>inet_ntop</code>.</li> </ul>"},{"location":"02-installation.html#install","title":"Install","text":"<p>The library is available on Packagist and should be installed using Composer. This can be  done by running the following command:</p> <pre><code>$ composer require darsyn/ip\n</code></pre> <p>Most modern frameworks will include Composer out of the box, but ensure the following file is included:</p> <pre><code>&lt;?php declare(strict_types=1);\n\nrequire __DIR__ . '/vendor/autoload.php';\n</code></pre>"},{"location":"03-overview.html","title":"Overview","text":"<p>IP addresses get automatically validated on creation through the static factory method; if the IP address supplied is invalid an <code>InvalidIpAddressException</code> will be thrown.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv4;\nuse Darsyn\\IP\\Exception;\n\ntry {\n    $ip = IPv4::factory('127.0.0.1');\n} catch (Exception\\InvalidIpAddressException $e) {\n    echo 'The IP address supplied is invalid!';\n}\n</code></pre>"},{"location":"03-overview.html#versions","title":"Versions","text":"<p>This library can work with version 4 addresses, version 6 addresses, or both formats interchangeably using the classes <code>Darsyn\\IP\\Version\\IPv4</code>, <code>Darsyn\\IP\\Version\\IPv6</code> and <code>Darsyn\\IP\\Version\\Multi</code> respectively.</p> <p>All versions implement <code>Darsyn\\IP\\IpInterface</code>, along with extra interfaces for each version:</p> <ul> <li><code>IPv4</code> implements <code>Darsyn\\IP\\Version\\Version4Interface</code>,</li> <li><code>IPv6</code> implements <code>Darsyn\\IP\\Version\\Version6Interface</code>,</li> <li><code>Multi</code> implements <code>Darsyn\\IP\\Version\\MultiVersionInterface</code>   (which in turn implements both <code>Version4Interface</code> and <code>Version6Interface</code>).</li> </ul> <p>If you try to use a version 6 address with the <code>IPv4</code> class, or a version 4 address with the <code>IPv6</code> class, then a <code>Darsyn\\IP\\Exception\\WrongVersionException</code> will be thrown.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv4;\nuse Darsyn\\IP\\Exception;\n\ntry {\n    $ip = IPv4::factory('::1');\n} catch (Exception\\WrongVersionException $e) {\n    echo 'Only version 4 IP addresses are allowed!';\n} catch (Exception\\InvalidIpAddressException $e) {\n    echo 'The IP address supplied is invalid!';\n}\n</code></pre> <p>Note: The <code>WrongVersionException</code> is provided to give finer control on handling errors. It extends <code>InvalidIpAddressException</code> so catching it isn't necessary.</p> <p>Each class has methods for determining the version:</p> <ul> <li><code>$ip-&gt;getVersion()</code> returns the IP address version (either <code>int(4)</code> or   <code>int(6)</code>). </li> <li><code>$ip-&gt;isVersion($version)</code> returns a boolean value on whether the <code>$ip</code> object   is the version specified in <code>$version</code> (which must be either <code>int(4)</code> or   <code>int(6)</code>).</li> <li><code>$ip-&gt;isVersion4()</code> returns a boolean value on whether the <code>$ip</code> object   contains a version 4 address.</li> <li><code>$ip-&gt;isVersion6()</code> returns a boolean value on whether the <code>$ip</code> object   contains a version 6 address.</li> </ul> <p>Note: When using the <code>Multi</code> class, the address version is determined by what embedding strategy is used rather than what notation was passed to the constructor.</p>"},{"location":"03-overview.html#instantiation","title":"Instantiation","text":"<p>All classes are instantiated using the <code>factory()</code> static method. This method validates the input and converts it into binary. In the case of the <code>Multi</code> class it also packs any version 4 addresses into a version 6 address.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\ntry {\n    $ip = new IP('127.0.0.1');\n} catch (\\Error) {\n    echo 'Cannot create IP using \"new\"; please use IP::factory() instead.';\n}\n</code></pre> <p>Many instances are constructed for all helper and type methods. Validating the input every time a new instance is constructed slows things down considerably, so to speed up internal processes the constructor does not perform any input validation. Because of this the constructor method has been kept private.</p>"},{"location":"03-overview.html#return-formats","title":"Return Formats","text":"<p>Once an IP object has been initialised, the IP address value can be returned in either human-readable format or in binary.</p> <p>This binary string will always be 4 bytes long when using <code>IPv4</code> and 16 bytes long when using <code>IPv6</code> and <code>Multi</code>.</p> <p>Human-readable format comes in 3 flavours:</p> <ul> <li>Dot notation is for IPv4 addresses, eg <code>127.0.0.1</code>.</li> <li>Compacted is for IPv6 addresses, eg <code>2001:db8::a60:8a2e:370:7334</code>.</li> <li>Expanded is for IPv6 addresses, eg <code>2001:0db8:0000:0000:0a60:8a2e:0370:7334</code>.</li> </ul>"},{"location":"03-overview.html#dot-address","title":"Dot Address","text":"<p><code>getDotAddress()</code> is only available for <code>IPv4</code> and <code>Multi</code> classes. Calling <code>getDotAddress()</code> on an instance of <code>Multi</code> that contains a version 6 address will result in a <code>WrongVersionException</code> being thrown.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\nuse Darsyn\\IP\\Exception;\n\n$ip = IP::factory('127.0.0.1');\n\ntry {\n    echo $ip-&gt;getDotAddress(); // string(\"127.0.0.1\")\n} catch (Exception\\WrongVersionException $e) {\n    echo 'Cannot convert a version 6 address to dot-notation!';\n}\n</code></pre>"},{"location":"03-overview.html#compacted-address","title":"Compacted Address","text":"<p><code>getCompactedAddress()</code> is only available for <code>IPv6</code> and <code>Multi</code> classes. Calling <code>getCompactedAddress()</code> on an instance of <code>Multi</code> that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\necho $ip-&gt;getCompactedAddress(); // string(\"::ffff:7f00:1\")\n</code></pre>"},{"location":"03-overview.html#expanded-address","title":"Expanded Address","text":"<p><code>getExpandedAddress()</code> is only available for <code>IPv6</code> and <code>Multi</code> classes. Calling <code>getExpandedAddress()</code> on an instance of <code>Multi</code> that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;getExpandedAddress(); // string(\"0000:0000:0000:0000:0000:ffff:7f00:0001\")\n</code></pre>"},{"location":"03-overview.html#protocol-appropriate-address","title":"Protocol Appropriate Address","text":"<p><code>getProtocolAppropriateAddress()</code> is only available for the <code>Multi</code> class. If the instance of <code>Multi</code> contains a version 4 address, it will be returned in dot notation, otherwise it returns a compacted version 6 address.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('::ffff:7f00:1');\n$ip-&gt;getProtocolAppropriateAddress(); // string(\"127.0.0.1\")\n</code></pre>"},{"location":"03-overview.html#binary","title":"Binary","text":"<p><code>getBinary()</code> returns the 16 byte (4 bytes if using <code>IPv4</code>) binary string of the IP address. This will most likely contain non-printable characters, so is not appropriate for displaying. </p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv4 as IP;\n\n// The IPv4 address \"80.111.111.112\" just so happens to be, when converted to\n// binary, the same as the binary for the ASCII string \"Poop\". Today you learnt\n// something new.\n\n$ip = IP::factory('80.111.111.112');\n$ip-&gt;getBinary(); // string(\"Poop\")\n</code></pre>"},{"location":"03-overview.html#string-casting","title":"String Casting","text":"<p>Previous versions of this documentation specified that string casting for IP objects was enabled to get the binary string, but that was unfortunately untrue. Now, string casting is enabled for all version classes and the <code>__toString()</code> method is promised in <code>Darsyn\\IP\\IpInterface</code>:</p> <ul> <li>String casting the <code>IPv4</code> class is the equivalent of <code>$ip-&gt;getDotAddress()</code>.</li> <li>String casting the <code>IPv6</code> class is the equivalent of   <code>$ip-&gt;getCompactedAddress()</code>.</li> <li>String casting the <code>Multi</code> class is the equivalent of   <code>$ip-&gt;getProtocolAppropriateAddress()</code>.</li> </ul> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('::ffff:7f00:1');\n$printableString = (string) $ip; // string(\"127.0.0.1\")\n</code></pre>"},{"location":"04-helpers.html","title":"Helper Methods","text":"<p>Helper methods are for working with IP address and CIDR subnet masks.</p> <p>Since IP objects are meant to be immutable, whenever an IP is returned it is returned as a new instance of <code>Darsyn\\IP\\IpInterface</code> rather than modifying the existing object - they are also returned as a static instance meaning an <code>IPv4</code> object would return a new <code>IPv4</code> object, an <code>IPv6</code> returns <code>IPv6</code>, etc.</p>"},{"location":"04-helpers.html#concepts","title":"Concepts","text":""},{"location":"04-helpers.html#cidr-subnet-mask","title":"CIDR (Subnet Mask)","text":"<p>Most of the the helper methods require a CIDR value. Anyone who has worked with CIDR notation before will most likely be used to a subnet mask between 0 and 32. However, since the <code>Multi</code> class deals with both IPv4 and IPv6 the CIDR values can range up to 128.</p> <p>Instances of <code>IPv4</code> will always deal with CIDR values between 0 and 32.</p> <p>Instances of <code>IPv6</code> will always deal with CIDR values between 0 and 128.</p> <p>Instances of <code>Multi</code> will:</p> <ul> <li>Detect if the IP address is a version 4 address (according to the embedding   strategy).</li> <li>If version 4 and the CIDR is less or equal to 32, attempt the method as if it   was called from an <code>IPv4</code> instance.</li> <li>Otherwise, attempt the method as if it was called from an <code>IPv6</code> instance.</li> </ul> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n// IP is version 4 address and CIDR is &lt;= 32. Uses IPv4::getNetworkIp().\nIP::factory('127.0.0.1')-&gt;getNetworkIp(26);\n\n// IP is version 4 address but CIDR is more than 32. Uses IPv6::getNetworkIp().\nIP::factory('127.0.0.1')-&gt;getNetworkIp(107);\n\n// IP is version 6 address. Uses IPv6::getNetworkIp(), even though CIDR is below 32.\nIP::factory('2001:db8::a60:8a2e:0:7334')-&gt;getNetworkIp(31);\n</code></pre> <p>A <code>Darsyn\\IP\\Exception\\InvalidCidrException</code> is thrown whenever a CIDR value that is out of range is supplied. Out of range values are any value that is:</p> <ul> <li>Not an integer,</li> <li>Below zero,</li> <li>Above 32 (for <code>IPv4</code>), or</li> <li>Above 128 (for <code>IPv6</code> and <code>Multi</code>).</li> </ul>"},{"location":"04-helpers.html#ip-comparison","title":"IP Comparison","text":"<p>Some of the helper methods accept another IP address to work against. To successfully compare IP address, both must be the same byte-length:</p> <ul> <li><code>IPv4</code> instances can only be compared against other, as internally they are   represented as 4-byte strings.</li> <li><code>IPv6</code> and <code>Multi</code> can be compared against themselves and each other, as   internally they are represented as 16-byte strings.</li> </ul> <p>When using the <code>Multi</code> class to call the helper method, it will attempt the method as if it was called from an <code>IPv4</code> instance if:</p> <ul> <li>Both are IPv4-embedded addresses, and</li> <li>Both are embedded using the same embedding strategy.</li> </ul> <p>Otherwise, <code>Multi</code> attempts the method as if it was called from an <code>IPv6</code> instance.</p>"},{"location":"04-helpers.html#examples","title":"Examples","text":"<pre><code>&lt;?php\n\n// IPv6 operation: helper method called from IPv6.\nIPv6::factory('ffff:7f00:1')-&gt;inRange(Multi::factory('127.0.0.1'), 23);\n\n// IPv4 operation: called from Multi, both IPs are IPv4-embedded, CIDR below 32.\nMulti::factory('127.0.0.1')-&gt;inRange(Multi::factory('127.0.0.1'), 23);\n\n// IPv6 operation: both IPv4-embedded, but CIDR above 32.\nMulti::factory('127.0.0.1')-&gt;inRange(Multi::factory('127.0.0.1'), 35);\n\n// IPv6 operation: supplied IP is not IPv4-embedded.\nMulti::factory('127.0.0.1')-&gt;inRange(Multi::factory('d6be:583:b07a::c7'), 23);\n\n// IPv6 operation: embedding strategies do not match.\nMulti::factory('127.0.0.1', new Mapped)\n    -&gt;inRange(Multi::factory('127.0.0.1', new Derived), 23);\n\n// WrongVersionException: Multi and IPv4 are different byte lengths.\nMulti::factory('127.0.0.1')-&gt;inRange(IPv4::factory('127.0.0.1'), 23);\n\n// InvalidCidrException: CIDR above 128.\nMulti::factory('127.0.0.1')-&gt;inRange(Multi::factory('127.0.0.1'), 129);\n</code></pre>"},{"location":"04-helpers.html#method-reference","title":"Method Reference","text":""},{"location":"04-helpers.html#network-ip","title":"Network IP","text":"<pre><code>@throws \\Darsyn\\IP\\Exception\\InvalidCidrException\n\ngetNetworkIp(int $cidr): IpInterface\n</code></pre> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('12.34.56.78');\n// Get the network address of an IP address given a subnet mask.\n$networkIp = $ip-&gt;getNetworkIp(19);\n$networkIp-&gt;getProtocolAppropriateAddress(); // string(\"12.34.32.0\")\n</code></pre>"},{"location":"04-helpers.html#broadcast-ip","title":"Broadcast IP","text":"<pre><code>@throws \\Darsyn\\IP\\Exception\\InvalidCidrException\n\ngetBroadcastIp(int $cidr): bool\n</code></pre> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('12.34.56.78');\n// Get the broadcast address of an IP address given a subnet mask.\n$broadcastIp = $ip-&gt;getBroadcastIp(19);\n$broadcastIp-&gt;getProtocolAppropriateAddress(); // string(\"12.34.63.255\")\n</code></pre>"},{"location":"04-helpers.html#is-ip-in-range","title":"Is IP in Range?","text":"<pre><code>@throws \\Darsyn\\IP\\Exception\\WrongVersionException\n@throws \\Darsyn\\IP\\Exception\\InvalidCidrException\n\ninRange(IpInterface $ip, int $cidr): bool\n</code></pre> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$hostIp = IP::factory(':ffff:c22:384e');\n$clientIp = IP::factory('12.48.183.1');\n\n$clientIp-&gt;inRange($hostIp, 11); // bool(true)\n$clientIp-&gt;inRange($hostIp, 24); // bool(false)\n</code></pre>"},{"location":"04-helpers.html#greatest-common-cidr","title":"Greatest Common CIDR","text":"<pre><code>@throws \\Darsyn\\IP\\Exception\\WrongVersionException\n\ngetCommonCidr(IpInterface $ip): int\n</code></pre> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$hostIp = IP::factory('d6be:583:71a4:aa6d:c77d:77dd:cec:f897');\n$clientIp = IP::factory('d6be:583:71a4:aa67:b07a::c7');\n$hostIp-&gt;getCommonCidr($clientIp); // int(60)\n</code></pre>"},{"location":"04-helpers.html#ipv6-vs-multi","title":"<code>IPv6</code> vs <code>Multi</code>?","text":"<p>The <code>Multi</code> class tries to deal with both IPv4 and IPv6 interchangeably which can lead to some unexpected results if an IPv6 address is detected as an IPv4-embedded address. Valid CIDR values can be either 0-32 or 0-128 depending on internal state and the embedding strategy used.</p> <p>All the helper methods of <code>Multi</code> are affected by this.</p> <p>The <code>IPv6</code> class, however, gives consistent results regardless of embedding strategy and always deals with CIDR values from 0 to 128.</p> <p>It is recommended that you pick a concrete version (either <code>IPv4</code> or <code>IPv6</code>) unless you absolutely know that you need to deal with both interchangeably. Using <code>Multi</code> can cause unexpected behaviour.</p> <p>For example, <code>Multi::factory('0.0.0.1', new Strategy\\Compatible)</code> results in an object which is both a loopback address <code>::1</code> if viewing as IPv6, but also not a loopback address <code>127.x.x.x</code> if viewing as an IPv4-embedded address.</p> <p>Use <code>Multi</code> with caution.</p>"},{"location":"04-helpers.html#ipv6-from-embedded","title":"IPv6 From Embedded","text":"<p>If you want to embed IPv4 addresses into IPv6, but do not want <code>Multi</code> to return varying results depending on whether an IPv4 address is embedded or not, then use <code>IPv6::fromEmbedded()</code>.</p> <p>It accepts both IPv4 and IPv6 addresses, embeds IPv4 addresses into IPv6 according to the embedding strategy, and from that point on treats it purely as an IPv6 address.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Strategy\\Mapped;\nuse Darsyn\\IP\\Version\\Ipv6;\n\n// Strategy is optional; defaults to Mapped unless\n// Multi::setDefaultEmbeddingStrategy() called previously.\n$ip = IPv6::fromEmbedded('127.0.0.1', new Mapped);\n$ip-&gt;getCompactedAddress(); // string(\"::ffff:7f00:1\")\n\ntry {\n    $ip-&gt;getDotAddress();\n} catch (\\Error $e) {\n    // IPv6 addresses are not considered IPv4 addresses and\n    // therefore do not have the method getDotAddress().\n}\n</code></pre> <p>Please note that calling <code>Multi::fromEmbedded()</code> returns an instance of <code>Multi</code> and effectively is the same as calling the factory method.</p>"},{"location":"05-strategies.html","title":"Embedding Strategies","text":"<p>When using version 4 and version 6 addresses interchangeably (via the  <code>Multi</code> class), version 4 addresses are embedded into version 6 addresses so that both versions are stored as 16-byte binary sequences.</p> <p>Unfortunately there are several different strategies for embedding a version 4 address into version 6, so this library offers various strategy implementations for the main three: </p> Strategy Name Implementation Format 6to4-derived <code>Darsyn\\IP\\Strategy\\Derived</code> <code>2002:XXXX:XXXX:0000:0000:0000:0000:0000</code> IPv4-compatible <code>Darsyn\\IP\\Strategy\\Compatible</code> <code>0000:0000:0000:0000:0000:0000:XXXX:XXXX</code> IPv4-mapped <code>Darsyn\\IP\\Strategy\\Mapped</code> <code>0000:0000:0000:0000:0000:ffff:XXXX:XXXX</code> <p>Each embedding strategy implements the <code>Darsyn\\IP\\Strategy\\EmbeddingStrategyInterface</code> which defines methods to:</p> <ul> <li>Detect whether a version 4 address is embedded into a version 6 address,</li> <li>Extracting a version 4 address from a version 6 address, and</li> <li>Packing a version 4 address into a version 6 address according to the given   strategy.</li> </ul>"},{"location":"05-strategies.html#specifying-a-strategy","title":"Specifying a Strategy","text":"<p>This library will automatically use the IPv4-mapped embedding strategy unless otherwise instructed.</p> <p>An embedding strategy can be specified globally or on a per-instance basis.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Strategy;\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n// Set the IPv4-compatible embedding strategy to be used globally.\nIP::setDefaultEmbeddingStrategy(new Strategy\\Compatible);\n\n// But for this specific instance use the 6to4-derived embedding strategy.\n$ip = IP::factory('127.0.0.1', new Strategy\\Derived);\n</code></pre>"},{"location":"06-formatters.html","title":"Formatters","text":"<p>Internally, this library uses the PHP functions <code>inet_pton</code> and <code>inet_ntop</code>. However the <code>inet_ntop</code> function formats some IP addresses in an inconsistent and non-standard way (for example, the IP address <code>::ffff:c22:384e</code> would be  returned as <code>::ffff:12.34.56.78</code> when converting its binary representation to human-readable protocol via <code>inet_ntop</code>).</p> <p>This library provides a pure-PHP implementation called <code>Darsyn\\IP\\Formatter\\ConsistentFormatter</code> to return IP addresses in the correct format, which is used by default.</p> <p>However should you wish to use the native implementation for any reason, you may set the <code>Darsyn\\IP\\Formatter\\NativeFormatter</code> globally:</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Formatter\\NativeFormatter;\nuse Darsyn\\IP\\Version\\Multi as IP;\n\nIP::setProtocolFormatter(new NativeFormatter);\n$ip = IP::factory('::ffff:c22:384e');\n$ip-&gt;getCompactedAddress(); // string(\"::ffff:12.34.56.78\")\n</code></pre>"},{"location":"07-types.html","title":"Type Methods","text":"<p>The type methods return a boolean value depending on whether the IP address is a certain type.</p>"},{"location":"07-types.html#detecting-embedding-strategies","title":"Detecting Embedding Strategies","text":""},{"location":"07-types.html#embedded","title":"Embedded?","text":"<p>Whether the IP is an IPv4 address embedded into an IPv6 address, according to the embedding strategy used when creating the IP object.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('::ffff:7f00:1');\n$ip-&gt;isEmbedded(); // bool(true)\n</code></pre> <p>If you would like to detect if the IP is an IPv4-embedded IPv6 address, according to RFC 4291 section 2.5.5, please use the following conditional statement:</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Strategy\\Derived;\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1', new Derived);\n$rfc4291 = $ip-&gt;isMapped() || $ip-&gt;isCompatible(); // bool(false)\n</code></pre>"},{"location":"07-types.html#mapped","title":"Mapped","text":"<p>Whether the IP is an IPv4-mapped IPv6 address (eg, <code>::ffff:7f00:1</code>), according to RFC 4291 section 2.5.5.2. The <code>IPv4</code> class will always return <code>bool(false)</code> for this method.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('::ffff:7f00:1');\n$ip-&gt;isMapped(); // bool(true)\n</code></pre>"},{"location":"07-types.html#derived","title":"Derived","text":"<p>Whether the IP is a 6to4-derived IPv6 address (eg, <code>2002:7f00:1::</code>), according to RFC 3056. The <code>IPv4</code> class will always return <code>bool(false)</code> for this method.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('2002:7f00:1::');\n$ip-&gt;isDerived(); // bool(true)\n</code></pre>"},{"location":"07-types.html#compatible","title":"Compatible","text":"<p>Whether the IP is an IPv4-compatible IPv6 address (eg, <code>::7f00:1</code>), according to RFC 4291 section 2.5.5.1. The <code>IPv4</code> class will always return <code>bool(false)</code> for this method.</p> <p>IPv4-compatible IPv6 addresses are deprecated in the RFC.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('::7f00:1');\n$ip-&gt;isCompatible(); // bool(true)\n</code></pre>"},{"location":"07-types.html#detecting-address-types","title":"Detecting Address Types","text":""},{"location":"07-types.html#link-local","title":"Link Local","text":"<p>Whether the IP is reserved for link-local usage, according to RFC 3927 (IPv4) or RFC 4291 section 2.4 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isLinkLocal(); // bool(false)\n</code></pre>"},{"location":"07-types.html#loopback","title":"Loopback","text":"<p>Whether the IP is a loopback address, according to RFC 1122 section 3.2.1.3 (IPv4) or RFC 4291 section 2.5.3 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isLoopback(); // bool(true)\n</code></pre>"},{"location":"07-types.html#multicast","title":"Multicast","text":"<p>Whether the IP is a multicast address, according to RFC 5771 (IPv4) or RFC 4291 section 2.7 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isMulticast(); // bool(false)\n</code></pre>"},{"location":"07-types.html#private-use","title":"Private Use","text":"<p>Whether the IP is for private use, according to RFC 1918 section 3 (IPv4) or RFC 4193 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isPrivateUse(); // bool(false)\n</code></pre>"},{"location":"07-types.html#unspecified","title":"Unspecified","text":"<p>Whether the IP is unspecified, according to RFC 5735 (IPv4) or RFC 2373 section 2.5.2 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isUnspecified(); // bool(false)\n</code></pre>"},{"location":"07-types.html#benchmarking","title":"Benchmarking","text":"<p>Whether the IP is reserved for network devices benchmarking, according to RFC 2544 corrected in errata 423 (IPv4) or RFC 5180 corrected in errata 1752 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isBenchmarking(); // bool(false)\n</code></pre>"},{"location":"07-types.html#documentation","title":"Documentation","text":"<p>Whether the IP is in range designated for documentation, according to RFC 5737 (IPv4) or RFC 3849 (IPv6).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isDocumentation(); // bool(false)\n</code></pre>"},{"location":"07-types.html#public-use-global","title":"Public Use (Global)","text":"<p>Whether the IP appears to be publicly/globally routable (please refer to the following:</p> <ul> <li>IANA IPv4 Special-Purpose Address Registry</li> <li>IANA IPv6 Special-Purpose Address Registry</li> </ul> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\n\n$ip = IP::factory('127.0.0.1');\n$ip-&gt;isPublicUse(); // bool(false)\n</code></pre>"},{"location":"07-types.html#ipv4-specific","title":"IPv4 Specific","text":"<p>These methods will throw a <code>WrongVersionException</code> if called from <code>Multi</code> on an IPv6 address (non IPv4-embedded).</p>"},{"location":"07-types.html#broadcast","title":"Broadcast","text":"<p>Whether the IP is a broadcast address, according to RFC 919.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv4;\n\nIPv4::factory('127.0.0.1')-&gt;isBroadcast(); // bool(false)\nIPv4::factory('255.255.255.255')-&gt;isBroadcast(); // bool(true)\n</code></pre>"},{"location":"07-types.html#reserved-for-future-use","title":"Reserved for Future Use","text":"<p>Whether the IP is reserved for future use, according to RFC 1112.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv4;\n\nIPv4::factory('127.0.0.1')-&gt;isFutureReserved(); // bool(false)\nIPv4::factory('255.34.85.169')-&gt;isFutureReserved(); // bool(true)\n</code></pre>"},{"location":"07-types.html#shared","title":"Shared","text":"<p>Whether the IP is part of the Shared Address Space, according to RFC 6598.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv4;\n\nIPv4::factory('100.128.179.30')-&gt;isShared(); // bool(false)\nIPv4::factory('100.127.43.2')-&gt;isShared(); // bool(true)\n</code></pre>"},{"location":"07-types.html#ipv6-specific","title":"IPv6 Specific","text":""},{"location":"07-types.html#multicast-scope","title":"Multicast Scope","text":"<p>The specific scope of the multicast address (returns <code>null</code> if not a multicast address). The following constants are available on <code>Darsyn\\IP\\Version\\Version6Interface</code>:</p> <ul> <li><code>MULTICAST_INTERFACE_LOCAL</code></li> <li><code>MULTICAST_LINK_LOCAL</code></li> <li><code>MULTICAST_REALM_LOCAL</code></li> <li><code>MULTICAST_ADMIN_LOCAL</code></li> <li><code>MULTICAST_SITE_LOCAL</code></li> <li><code>MULTICAST_ORGANIZATION_LOCAL</code></li> <li><code>MULTICAST_GLOBAL</code></li> </ul> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv6;\n\n$isOrganizationLocal = IPv6::factory('ff08:1:6e6f:cbb::980e:3816')-&gt;getMulticastScope() === IPv6::MULTICAST_ORGANIZATION_LOCAL; // bool(true)\n</code></pre>"},{"location":"07-types.html#unique-local","title":"Unique Local","text":"<p>Whether the IP is a unique local address, according to RFC 4193.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv6;\n\nIPv6::factory('b638:cc70:716:c4d4:f69c:4ee3:6c65:a0b2')-&gt;isUniqueLocal(); // bool(false)\nIPv6::factory('fdff:ffff::')-&gt;isUniqueLocal(); // bool(true)\n</code></pre>"},{"location":"07-types.html#unicast","title":"Unicast","text":"<p>Whether the IP is a unicast address, according to RFC 4291 (any IPv6 address that is not a multicast address is unicast, and vice-versa).</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv6;\n\nIPv6::factory('ff08::')-&gt;isUnicast(); // bool(false)\nIPv6::factory('::ffff:1:0')-&gt;isUnicast(); // bool(true)\n</code></pre>"},{"location":"07-types.html#unicast-global","title":"Unicast Global","text":"<p>Whether the IP is a globally routable unicast address, according to RFC 4291 section 2.5.4.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\IPv6;\n\nIPv6::factory('2001:db8:85a3::8a2e:370:7334')-&gt;isUnicastGlobal(); // bool(false)\nIPv6::factory('140c:12f1:6e6f:c0bb:980e:3816:3e52:1193')-&gt;isUnicastGlobal(); // bool(true)\n</code></pre>"},{"location":"08-doctrine.html","title":"Doctrine Support","text":"<p>This documentation is for the package <code>darsyn/ip-doctrine</code>, which was split into a separate package in v5+ so that PHP version requirements could be updated independently. Require that as a Composer dependency to use this functionality.</p> <p>This library can be used to support IP address as column types with Doctrine DBAL versions <code>^2.3 || ^3.0</code>.</p> <p>Three Doctrine types are provided to match the three version classes:</p> <ul> <li><code>Darsyn\\IP\\Doctrine\\IPV4Type</code> supports the <code>IPv4</code> class.</li> <li><code>Darsyn\\IP\\Doctrine\\IPV6Type</code> supports the <code>IPv6</code> class.</li> <li><code>Darsyn\\IP\\Doctrine\\MultiType</code> supports the <code>Multi</code> class.</li> </ul> <pre><code>&lt;?php\nuse Darsyn\\IP\\Doctrine\\MultiType;\nuse Doctrine\\DBAL\\Types\\Type;\n\nType::addType('ip', MultiType::class);\n</code></pre> <p>If you are using Symfony, then add the following to your main configuration:</p> <pre><code>doctrine:\n    dbal:\n        types:\n            ip: Darsyn\\IP\\Doctrine\\MultiType\n</code></pre> <p>Now you can happily store IP addresses in your entities like nobody's business:</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Version\\Multi as IP;\nuse Doctrine\\ORM\\Mapping as ORM;\n\n#[ORM\\Entity]\nclass AnalyticsEntity\n{\n     #[ORM\\Column(type: 'ip')]\n    public IP $ipAddress;\n}\n</code></pre>"},{"location":"09-utilities.html","title":"Utilities","text":""},{"location":"09-utilities.html#binary-utility","title":"Binary Utility","text":"<p>The IP value objects store their internal state as a binary string, which is not easy for humans to understand. The <code>Darsyn\\IP\\Util\\Binary</code> class is a collection of static helper methods for dealing with such binary strings.</p>"},{"location":"09-utilities.html#from-hexadecimal","title":"From Hexadecimal","text":"<pre><code>@throws \\InvalidArgumentException\n\n\\Darsyn\\IP\\Util\\Binary::fromHex(string $hex): string\n</code></pre> <p>Because there are two hexadecimal characters per byte, the input string must be of a length that is a multiple of 2.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Util\\Binary;\n\n$hexString = '48656c6c6f21';\nBinary::fromHex($hexString); // string(\"Hello!\")\n</code></pre>"},{"location":"09-utilities.html#to-hexadecimal","title":"To Hexadecimal","text":"<pre><code>@throws \\InvalidArgumentException\n\n\\Darsyn\\IP\\Util\\Binary::toHex(string $hex): string\n</code></pre> <pre><code>&lt;?php\nuse Darsyn\\IP\\Util\\Binary;\n\n$binaryString = 'Hello!';\nBinary::toHex($binaryString); // string(\"48656c6c6f21\")\n</code></pre>"},{"location":"09-utilities.html#from-human-readable-binary","title":"From Human-readable Binary","text":"<pre><code>@throws \\InvalidArgumentException\n\n\\Darsyn\\IP\\Util\\Binary::fromHumanReadable(string $asciiBinarySequence): string\n</code></pre> <p>Because there are 8 bits per bytes, the input string must be of a length that is a multiple of 8.</p> <pre><code>&lt;?php\nuse Darsyn\\IP\\Util\\Binary;\n\n$asciiBinary = '010010000110010101101100011011000110111100100001';\nBinary::fromHumanReadable($asciiBinary); // string(\"Hello!\")\n</code></pre>"},{"location":"09-utilities.html#to-human-readable","title":"To Human-readable","text":"<pre><code>@throws \\InvalidArgumentException\n\n\\Darsyn\\IP\\Util\\Binary::toHumanReadable(string $binary): string\n</code></pre> <pre><code>&lt;?php\nuse Darsyn\\IP\\Util\\Binary;\n\n$binaryString = 'Hello!';\nBinary::toHumanReadable($asciiBinary); // string(\"010010000110010101101100011011000110111100100001\")\n</code></pre>"},{"location":"09-utilities.html#multibyte-string-utility","title":"Multibyte String Utility","text":"<p>On some PHP installations, the Multibyte String extension can overload PHP's native string functions which, because we are working with arbitrary binary content, can incorrectly guess an encoding when attempting to transform this data (IP addresses have no text encoding).</p> <p>Because of this, the <code>Darsyn\\IP\\Util\\MbString</code> class is a collection of static helper equivalents for PHP's core string functions which detect if the <code>mbstring</code> extension is installed and appropriately call the correct function, specifying the <code>8bit</code> text encoding (treat each byte as individual character) if required.</p> Static Helper Method Replaces the PHP function... <code>MbString::getLength()</code> <code>str_len()</code> <code>MbString::subString()</code> <code>substr()</code> <code>MbString::padString()</code> <code>str_pad()</code>"},{"location":"10-api.html","title":"API Reference","text":"Method Returns IPv4 IPv6 Multi <code>factory(string $ip, [$strategy])</code> Static <code>IpInterface</code> \u2713 \u2713 \u2713 <code>getBinary()</code> <code>string</code> \u2713 \u2713 \u2713 <code>equals(IpInterface $ip)</code> <code>bool</code> \u2713 \u2713 \u2713 <code>getVersion()</code> <code>int</code> \u2713 \u2713 \u2713 <code>isVersion(int $version)</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isVersion4()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isVersion6()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>getNetworkIp(int $cidr)</code> Static <code>IpInterface</code> \u2713 \u2713 \u2713 <code>getBroadcastIp(int $cidr)</code> Static <code>IpInterface</code> \u2713 \u2713 \u2713 <code>inRange(IpInterface $ip, int $cidr)</code> <code>bool</code> \u2713 \u2713 \u2713 <code>getCommonCidr(IpInterface $ip)</code> <code>int</code> \u2713 \u2713 \u2713 <code>isMapped()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isDerived()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isCompatible()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isEmbedded()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isLinkLocal()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isLoopback()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isMulticast()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isPrivateUse()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isUnspecified()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isBenchmarking()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isDocumentation()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isPublicUse()</code> <code>bool</code> \u2713 \u2713 \u2713 <code>isBroadcast()</code> <code>bool</code> \u2713 \u2713 <code>isShared()</code> <code>bool</code> \u2713 \u2713 <code>isFutureReserved()</code> <code>bool</code> \u2713 \u2713 <code>getDotAddress()</code> <code>string</code> \u2713 \u2713 <code>getCompactedAddress()</code> <code>string</code> \u2713 \u2713 <code>getExpandedAddress()</code> <code>string</code> \u2713 \u2713 <code>getCompactedAddress()</code> <code>string</code> \u2713 \u2713 <code>getMulticastScope()</code> <code>?int</code> \u2713 \u2713 <code>isUniqueLocal()</code> <code>bool</code> \u2713 \u2713 <code>isUnicast()</code> <code>bool</code> \u2713 \u2713 <code>isUnicastGlobal()</code> <code>bool</code> \u2713 \u2713 <code>getProtocolAppropriateAddress()</code> <code>string</code> \u2713"}]}