{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Introduction IP is an immutable value object for (both version 4 and 6) IP addresses. Several helper methods are provided for ranges, broadcast and network addresses, subnet masks, whether an IP is a certain type (defined by RFC's), etc. Internally, the library converts IP addresses to a binary sequence for easy mathematical operations and consistency. You can choose to work with IPv6 addresses as 16-byte binary sequences, IPv4 addresses as 4-byte binary sequences, or work with both interchangeably by representing IPv4 addresses as 16-byte binary sequences (which is recommended for most applications). License Please see the separate license file included in this repository for a full copy of the MIT license , which this project is licensed under. Authors Zan Baldwin Jaume Casado Ruiz Pascal Hofmann If you make a contribution (submit a pull request), don't forget to add your name here!","title":"Introduction"},{"location":"index.html#introduction","text":"IP is an immutable value object for (both version 4 and 6) IP addresses. Several helper methods are provided for ranges, broadcast and network addresses, subnet masks, whether an IP is a certain type (defined by RFC's), etc. Internally, the library converts IP addresses to a binary sequence for easy mathematical operations and consistency. You can choose to work with IPv6 addresses as 16-byte binary sequences, IPv4 addresses as 4-byte binary sequences, or work with both interchangeably by representing IPv4 addresses as 16-byte binary sequences (which is recommended for most applications).","title":"Introduction"},{"location":"index.html#license","text":"Please see the separate license file included in this repository for a full copy of the MIT license , which this project is licensed under.","title":"License"},{"location":"index.html#authors","text":"Zan Baldwin Jaume Casado Ruiz Pascal Hofmann If you make a contribution (submit a pull request), don't forget to add your name here!","title":"Authors"},{"location":"02-installation.html","text":"Installation System Requirements All functionality can be implemented without using new language features, so this library will support PHP versions 5.6 onwards. This library cannot be used on 32-bits systems due to a dependency on the in-built PHP functions inet_pton and inet_ntop . Install The library is available on Packagist and should be installed using Composer . This can be done by running the following command: $ composer require darsyn/ip Most modern frameworks will include Composer out of the box, but ensure the following file is included: <?php declare ( strict_types = 1 ); require __DIR__ . '/vendor/autoload.php' ;","title":"Installation"},{"location":"02-installation.html#installation","text":"","title":"Installation"},{"location":"02-installation.html#system-requirements","text":"All functionality can be implemented without using new language features, so this library will support PHP versions 5.6 onwards. This library cannot be used on 32-bits systems due to a dependency on the in-built PHP functions inet_pton and inet_ntop .","title":"System Requirements"},{"location":"02-installation.html#install","text":"The library is available on Packagist and should be installed using Composer . This can be done by running the following command: $ composer require darsyn/ip Most modern frameworks will include Composer out of the box, but ensure the following file is included: <?php declare ( strict_types = 1 ); require __DIR__ . '/vendor/autoload.php' ;","title":"Install"},{"location":"03-overview.html","text":"Overview IP addresses get automatically validated on creation through the static factory method; if the IP address supplied is invalid an InvalidIpAddressException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4 ; use Darsyn\\IP\\Exception ; try { $ip = IPv4 :: factory ( '127.0.0.1' ); } catch ( Exception\\InvalidIpAddressException $e ) { echo 'The IP address supplied is invalid!' ; } Versions This library can work with version 4 addresses, version 6 addresses, or both formats interchangeably using the classes Darsyn\\IP\\Version\\IPv4 , Darsyn\\IP\\Version\\IPv6 and Darsyn\\IP\\Version\\Multi respectively. All versions implement Darsyn\\IP\\IpInterface , along with extra interfaces for each version: IPv4 implements Darsyn\\IP\\Version\\Version4Interface , IPv6 implements Darsyn\\IP\\Version\\Version6Interface , Multi implements Darsyn\\IP\\Version\\MultiVersionInterface (which in turn implements both Version4Interface and Version6Interface ). If you try to use a version 6 address with the IPv4 class, or a version 4 address with the IPv6 class, then a Darsyn\\IP\\Exception\\WrongVersionException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4 ; use Darsyn\\IP\\Exception ; try { $ip = IPv4 :: factory ( '::1' ); } catch ( Exception\\WrongVersionException $e ) { echo 'Only version 4 IP addresses are allowed!' ; } catch ( Exception\\InvalidIpAddressException $e ) { echo 'The IP address supplied is invalid!' ; } Note: The WrongVersionException is provided to give finer control on handling errors. It extends InvalidIpAddressException so catching it isn't necessary. Each class has methods for determining the version: $ip->getVersion() returns the IP address version (either int(4) or int(6) ). $ip->isVersion($version) returns a boolean value on whether the $ip object is the version specified in $version (which must be either int(4) or int(6) ). $ip->isVersion4() returns a boolean value on whether the $ip object contains a version 4 address. $ip->isVersion6() returns a boolean value on whether the $ip object contains a version 6 address. Note: When using the Multi class, the address version is determined by what embedding strategy is used rather than what notation was passed to the constructor. Instantiation All classes are instantiated using the factory() static method. This method validates the input and converts it into binary. In the case of the Multi class it also packs any version 4 addresses into a version 6 address. <?php use Darsyn\\IP\\Version\\Multi as IP ; try { $ip = new IP ( '127.0.0.1' ); } catch ( \\Error ) { echo 'Cannot create IP using \"new\"; please use IP::factory() instead.' ; } Many instances are constructed for all helper and type methods. Validating the input every time a new instance is constructed slows things down considerably, so to speed up internal processes the constructor does not perform any input validation. Because of this the constructor method has been kept private. Return Formats Once an IP object has been initialised, the IP address value can be returned in either human-readable format or in binary. This binary string will always be 4 bytes long when using IPv4 and 16 bytes long when using IPv6 and Multi . Human-readable format comes in 3 flavours: Dot notation is for IPv4 addresses, eg 127.0.0.1 . Compacted is for IPv6 addresses, eg 2001:db8::a60:8a2e:370:7334 . Expanded is for IPv6 addresses, eg 2001:0db8:0000:0000:0a60:8a2e:0370:7334 . Dot Address getDotAddress() is only available for IPv4 and Multi classes. Calling getDotAddress() on an instance of Multi that contains a version 6 address will result in a WrongVersionException being thrown. <?php use Darsyn\\IP\\Version\\Multi as IP ; use Darsyn\\IP\\Exception ; $ip = IP :: factory ( '127.0.0.1' ); try { echo $ip -> getDotAddress (); // string(\"127.0.0.1\") } catch ( Exception\\WrongVersionException $e ) { echo 'Cannot convert a version 6 address to dot-notation!' ; } Compacted Address getCompactedAddress() is only available for IPv6 and Multi classes. Calling getCompactedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); echo $ip -> getCompactedAddress (); // string(\"::ffff:7f00:1\") Expanded Address getExpandedAddress() is only available for IPv6 and Multi classes. Calling getExpandedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> getExpandedAddress (); // string(\"0000:0000:0000:0000:0000:ffff:7f00:0001\") Protocol Appropriate Address getProtocolAppropriateAddress() is only available for the Multi class. If the instance of Multi contains a version 4 address, it will be returned in dot notation, otherwise it returns a compacted version 6 address. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $ip -> getProtocolAppropriateAddress (); // string(\"127.0.0.1\") Binary getBinary() returns the 16 byte (4 bytes if using IPv4 ) binary string of the IP address. This will most likely contain non-printable characters, so is not appropriate for displaying. <?php use Darsyn\\IP\\Version\\IPv4 as IP ; // The IPv4 address \"80.111.111.112\" just so happens to be, when converted to // binary, the same as the binary for the ASCII string \"Poop\". Today you learnt // something new. $ip = IP :: factory ( '80.111.111.112' ); $ip -> getBinary (); // string(\"Poop\") String Casting Previous versions of this documentation specified that string casting for IP objects was enabled to get the binary string, but that was unfortunately untrue. Now, string casting is enabled for all version classes and the __toString() method is promised in Darsyn\\IP\\IpInterface : String casting the IPv4 class is the equivalent of $ip->getDotAddress() . String casting the IPv6 class is the equivalent of $ip->getCompactedAddress() . String casting the Multi class is the equivalent of $ip->getProtocolAppropriateAddress() . <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $printableString = ( string ) $ip ; // string(\"127.0.0.1\")","title":"Overview"},{"location":"03-overview.html#overview","text":"IP addresses get automatically validated on creation through the static factory method; if the IP address supplied is invalid an InvalidIpAddressException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4 ; use Darsyn\\IP\\Exception ; try { $ip = IPv4 :: factory ( '127.0.0.1' ); } catch ( Exception\\InvalidIpAddressException $e ) { echo 'The IP address supplied is invalid!' ; }","title":"Overview"},{"location":"03-overview.html#versions","text":"This library can work with version 4 addresses, version 6 addresses, or both formats interchangeably using the classes Darsyn\\IP\\Version\\IPv4 , Darsyn\\IP\\Version\\IPv6 and Darsyn\\IP\\Version\\Multi respectively. All versions implement Darsyn\\IP\\IpInterface , along with extra interfaces for each version: IPv4 implements Darsyn\\IP\\Version\\Version4Interface , IPv6 implements Darsyn\\IP\\Version\\Version6Interface , Multi implements Darsyn\\IP\\Version\\MultiVersionInterface (which in turn implements both Version4Interface and Version6Interface ). If you try to use a version 6 address with the IPv4 class, or a version 4 address with the IPv6 class, then a Darsyn\\IP\\Exception\\WrongVersionException will be thrown. <?php use Darsyn\\IP\\Version\\IPv4 ; use Darsyn\\IP\\Exception ; try { $ip = IPv4 :: factory ( '::1' ); } catch ( Exception\\WrongVersionException $e ) { echo 'Only version 4 IP addresses are allowed!' ; } catch ( Exception\\InvalidIpAddressException $e ) { echo 'The IP address supplied is invalid!' ; } Note: The WrongVersionException is provided to give finer control on handling errors. It extends InvalidIpAddressException so catching it isn't necessary. Each class has methods for determining the version: $ip->getVersion() returns the IP address version (either int(4) or int(6) ). $ip->isVersion($version) returns a boolean value on whether the $ip object is the version specified in $version (which must be either int(4) or int(6) ). $ip->isVersion4() returns a boolean value on whether the $ip object contains a version 4 address. $ip->isVersion6() returns a boolean value on whether the $ip object contains a version 6 address. Note: When using the Multi class, the address version is determined by what embedding strategy is used rather than what notation was passed to the constructor.","title":"Versions"},{"location":"03-overview.html#instantiation","text":"All classes are instantiated using the factory() static method. This method validates the input and converts it into binary. In the case of the Multi class it also packs any version 4 addresses into a version 6 address. <?php use Darsyn\\IP\\Version\\Multi as IP ; try { $ip = new IP ( '127.0.0.1' ); } catch ( \\Error ) { echo 'Cannot create IP using \"new\"; please use IP::factory() instead.' ; } Many instances are constructed for all helper and type methods. Validating the input every time a new instance is constructed slows things down considerably, so to speed up internal processes the constructor does not perform any input validation. Because of this the constructor method has been kept private.","title":"Instantiation"},{"location":"03-overview.html#return-formats","text":"Once an IP object has been initialised, the IP address value can be returned in either human-readable format or in binary. This binary string will always be 4 bytes long when using IPv4 and 16 bytes long when using IPv6 and Multi . Human-readable format comes in 3 flavours: Dot notation is for IPv4 addresses, eg 127.0.0.1 . Compacted is for IPv6 addresses, eg 2001:db8::a60:8a2e:370:7334 . Expanded is for IPv6 addresses, eg 2001:0db8:0000:0000:0a60:8a2e:0370:7334 .","title":"Return Formats"},{"location":"03-overview.html#dot-address","text":"getDotAddress() is only available for IPv4 and Multi classes. Calling getDotAddress() on an instance of Multi that contains a version 6 address will result in a WrongVersionException being thrown. <?php use Darsyn\\IP\\Version\\Multi as IP ; use Darsyn\\IP\\Exception ; $ip = IP :: factory ( '127.0.0.1' ); try { echo $ip -> getDotAddress (); // string(\"127.0.0.1\") } catch ( Exception\\WrongVersionException $e ) { echo 'Cannot convert a version 6 address to dot-notation!' ; }","title":"Dot Address"},{"location":"03-overview.html#compacted-address","text":"getCompactedAddress() is only available for IPv6 and Multi classes. Calling getCompactedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); echo $ip -> getCompactedAddress (); // string(\"::ffff:7f00:1\")","title":"Compacted Address"},{"location":"03-overview.html#expanded-address","text":"getExpandedAddress() is only available for IPv6 and Multi classes. Calling getExpandedAddress() on an instance of Multi that contains a version 4 address will result in the IP address being converted to a version 6 address according to the embedding strategy. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> getExpandedAddress (); // string(\"0000:0000:0000:0000:0000:ffff:7f00:0001\")","title":"Expanded Address"},{"location":"03-overview.html#protocol-appropriate-address","text":"getProtocolAppropriateAddress() is only available for the Multi class. If the instance of Multi contains a version 4 address, it will be returned in dot notation, otherwise it returns a compacted version 6 address. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $ip -> getProtocolAppropriateAddress (); // string(\"127.0.0.1\")","title":"Protocol Appropriate Address"},{"location":"03-overview.html#binary","text":"getBinary() returns the 16 byte (4 bytes if using IPv4 ) binary string of the IP address. This will most likely contain non-printable characters, so is not appropriate for displaying. <?php use Darsyn\\IP\\Version\\IPv4 as IP ; // The IPv4 address \"80.111.111.112\" just so happens to be, when converted to // binary, the same as the binary for the ASCII string \"Poop\". Today you learnt // something new. $ip = IP :: factory ( '80.111.111.112' ); $ip -> getBinary (); // string(\"Poop\")","title":"Binary"},{"location":"03-overview.html#string-casting","text":"Previous versions of this documentation specified that string casting for IP objects was enabled to get the binary string, but that was unfortunately untrue. Now, string casting is enabled for all version classes and the __toString() method is promised in Darsyn\\IP\\IpInterface : String casting the IPv4 class is the equivalent of $ip->getDotAddress() . String casting the IPv6 class is the equivalent of $ip->getCompactedAddress() . String casting the Multi class is the equivalent of $ip->getProtocolAppropriateAddress() . <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $printableString = ( string ) $ip ; // string(\"127.0.0.1\")","title":"String Casting"},{"location":"04-helpers.html","text":"Helper Methods Helper methods are for working with IP address and CIDR subnet masks. Since IP objects are meant to be immutable, whenever an IP is returned it is returned as a new instance of Darsyn\\IP\\IpInterface rather than modifying the existing object - they are also returned as a static instance meaning an IPv4 object would return a new IPv4 object, an IPv6 returns IPv6 , etc. Concepts CIDR (Subnet Mask) Most of the the helper methods require a CIDR value. Anyone who has worked with CIDR notation before will most likely be used to a subnet mask between 0 and 32. However, since the Multi class deals with both IPv4 and IPv6 the CIDR values can range up to 128. Instances of IPv4 will always deal with CIDR values between 0 and 32. Instances of IPv6 will always deal with CIDR values between 0 and 128. Instances of Multi will: Detect if the IP address is a version 4 address (according to the embedding strategy). If version 4 and the CIDR is less or equal to 32, attempt the method as if it was called from an IPv4 instance. Otherwise, attempt the method as if it was called from an IPv6 instance. <?php use Darsyn\\IP\\Version\\Multi as IP ; // IP is version 4 address and CIDR is <= 32. Uses IPv4::getNetworkIp(). IP :: factory ( '127.0.0.1' ) -> getNetworkIp ( 26 ); // IP is version 4 address but CIDR is more than 32. Uses IPv6::getNetworkIp(). IP :: factory ( '127.0.0.1' ) -> getNetworkIp ( 107 ); // IP is version 6 address. Uses IPv6::getNetworkIp(), even though CIDR is below 32. IP :: factory ( '2001:db8::a60:8a2e:0:7334' ) -> getNetworkIp ( 31 ); A Darsyn\\IP\\Exception\\InvalidCidrException is thrown whenever a CIDR value that is out of range is supplied. Out of range values are any value that is: Not an integer, Below zero, Above 32 (for IPv4 ), or Above 128 (for IPv6 and Multi ). IP Comparison Some of the helper methods accept another IP address to work against. To successfully compare IP address, both must be the same byte-length: IPv4 instances can only be compared against other, as internally they are represented as 4-byte strings. IPv6 and Multi can be compared against themselves and each other, as internally they are represented as 16-byte strings. When using the Multi class to call the helper method, it will attempt the method as if it was called from an IPv4 instance if: Both are IPv4-embedded addresses, and Both are embedded using the same embedding strategy . Otherwise, Multi attempts the method as if it was called from an IPv6 instance. Examples <?php // IPv6 operation: helper method called from IPv6. IPv6 :: factory ( 'ffff:7f00:1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 23 ); // IPv4 operation: called from Multi, both IPs are IPv4-embedded, CIDR below 32. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 23 ); // IPv6 operation: both IPv4-embedded, but CIDR above 32. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 35 ); // IPv6 operation: supplied IP is not IPv4-embedded. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( 'd6be:583:b07a::c7' ), 23 ); // IPv6 operation: embedding strategies do not match. Multi :: factory ( '127.0.0.1' , new Mapped ) -> inRange ( Multi :: factory ( '127.0.0.1' , new Derived ), 23 ); // WrongVersionException: Multi and IPv4 are different byte lengths. Multi :: factory ( '127.0.0.1' ) -> inRange ( IPv4 :: factory ( '127.0.0.1' ), 23 ); // InvalidCidrException: CIDR above 128. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 129 ); Method Reference Network IP @throws \\Darsyn\\IP\\Exception\\InvalidCidrException getNetworkIp(int $cidr): IpInterface <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '12.34.56.78' ); // Get the network address of an IP address given a subnet mask. $networkIp = $ip -> getNetworkIp ( 19 ); $networkIp -> getProtocolAppropriateAddress (); // string(\"12.34.32.0\") Broadcast IP @throws \\Darsyn\\IP\\Exception\\InvalidCidrException getBroadcastIp(int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '12.34.56.78' ); // Get the broadcast address of an IP address given a subnet mask. $broadcastIp = $ip -> getBroadcastIp ( 19 ); $broadcastIp -> getProtocolAppropriateAddress (); // string(\"12.34.63.255\") Is IP in Range? @throws \\Darsyn\\IP\\Exception\\WrongVersionException @throws \\Darsyn\\IP\\Exception\\InvalidCidrException inRange(IpInterface $ip, int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP ; $hostIp = IP :: factory ( ':ffff:c22:384e' ); $clientIp = IP :: factory ( '12.48.183.1' ); $clientIp -> inRange ( $hostIp , 11 ); // bool(true) $clientIp -> inRange ( $hostIp , 24 ); // bool(false) Greatest Common CIDR @throws \\Darsyn\\IP\\Exception\\WrongVersionException getCommonCidr(IpInterface $ip): int <?php use Darsyn\\IP\\Version\\Multi as IP ; $hostIp = IP :: factory ( 'd6be:583:71a4:aa6d:c77d:77dd:cec:f897' ); $clientIp = IP :: factory ( 'd6be:583:71a4:aa67:b07a::c7' ); $hostIp -> getCommonCidr ( $clientIp ); // int(60) IPv6 vs Multi ? The Multi class tries to deal with both IPv4 and IPv6 interchangeably which can lead to some unexpected results if an IPv6 address is detected as an IPv4-embedded address. Valid CIDR values can be either 0-32 or 0-128 depending on internal state and the embedding strategy used. All the helper methods of Multi are affected by this. The IPv6 class, however, gives consistent results regardless of embedding strategy and always deals with CIDR values from 0 to 128. It is recommended that you pick a concrete version (either IPv4 or IPv6 ) unless you absolutely know that you need to deal with both interchangeably. Using Multi can cause unexpected behaviour. For example, Multi::factory('0.0.0.1', new Strategy\\Compatible) results in an object which is both a loopback address ::1 if viewing as IPv6, but also not a loopback address 127.x.x.x if viewing as an IPv4-embedded address. Use Multi with caution. IPv6 From Embedded If you want to embed IPv4 addresses into IPv6, but do not want Multi to return varying results depending on whether an IPv4 address is embedded or not, then use IPv6::fromEmbedded() . It accepts both IPv4 and IPv6 addresses, embeds IPv4 addresses into IPv6 according to the embedding strategy, and from that point on treats it purely as an IPv6 address. <?php use Darsyn\\IP\\Strategy\\Mapped ; use Darsyn\\IP\\Version\\Ipv6 ; // Strategy is optional; defaults to Mapped unless // Multi::setDefaultEmbeddingStrategy() called previously. $ip = IPv6 :: fromEmbedded ( '127.0.0.1' , new Mapped ); $ip -> getCompactedAddress (); // string(\"::ffff:7f00:1\") try { $ip -> getDotAddress (); } catch ( \\Error $e ) { // IPv6 addresses are not considered IPv4 addresses and // therefore do not have the method getDotAddress(). } Please note that calling Multi::fromEmbedded() returns an instance of Multi and effectively is the same as calling the factory method.","title":"Helper Methods"},{"location":"04-helpers.html#helper-methods","text":"Helper methods are for working with IP address and CIDR subnet masks. Since IP objects are meant to be immutable, whenever an IP is returned it is returned as a new instance of Darsyn\\IP\\IpInterface rather than modifying the existing object - they are also returned as a static instance meaning an IPv4 object would return a new IPv4 object, an IPv6 returns IPv6 , etc.","title":"Helper Methods"},{"location":"04-helpers.html#concepts","text":"","title":"Concepts"},{"location":"04-helpers.html#cidr-subnet-mask","text":"Most of the the helper methods require a CIDR value. Anyone who has worked with CIDR notation before will most likely be used to a subnet mask between 0 and 32. However, since the Multi class deals with both IPv4 and IPv6 the CIDR values can range up to 128. Instances of IPv4 will always deal with CIDR values between 0 and 32. Instances of IPv6 will always deal with CIDR values between 0 and 128. Instances of Multi will: Detect if the IP address is a version 4 address (according to the embedding strategy). If version 4 and the CIDR is less or equal to 32, attempt the method as if it was called from an IPv4 instance. Otherwise, attempt the method as if it was called from an IPv6 instance. <?php use Darsyn\\IP\\Version\\Multi as IP ; // IP is version 4 address and CIDR is <= 32. Uses IPv4::getNetworkIp(). IP :: factory ( '127.0.0.1' ) -> getNetworkIp ( 26 ); // IP is version 4 address but CIDR is more than 32. Uses IPv6::getNetworkIp(). IP :: factory ( '127.0.0.1' ) -> getNetworkIp ( 107 ); // IP is version 6 address. Uses IPv6::getNetworkIp(), even though CIDR is below 32. IP :: factory ( '2001:db8::a60:8a2e:0:7334' ) -> getNetworkIp ( 31 ); A Darsyn\\IP\\Exception\\InvalidCidrException is thrown whenever a CIDR value that is out of range is supplied. Out of range values are any value that is: Not an integer, Below zero, Above 32 (for IPv4 ), or Above 128 (for IPv6 and Multi ).","title":"CIDR (Subnet Mask)"},{"location":"04-helpers.html#ip-comparison","text":"Some of the helper methods accept another IP address to work against. To successfully compare IP address, both must be the same byte-length: IPv4 instances can only be compared against other, as internally they are represented as 4-byte strings. IPv6 and Multi can be compared against themselves and each other, as internally they are represented as 16-byte strings. When using the Multi class to call the helper method, it will attempt the method as if it was called from an IPv4 instance if: Both are IPv4-embedded addresses, and Both are embedded using the same embedding strategy . Otherwise, Multi attempts the method as if it was called from an IPv6 instance.","title":"IP Comparison"},{"location":"04-helpers.html#examples","text":"<?php // IPv6 operation: helper method called from IPv6. IPv6 :: factory ( 'ffff:7f00:1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 23 ); // IPv4 operation: called from Multi, both IPs are IPv4-embedded, CIDR below 32. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 23 ); // IPv6 operation: both IPv4-embedded, but CIDR above 32. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 35 ); // IPv6 operation: supplied IP is not IPv4-embedded. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( 'd6be:583:b07a::c7' ), 23 ); // IPv6 operation: embedding strategies do not match. Multi :: factory ( '127.0.0.1' , new Mapped ) -> inRange ( Multi :: factory ( '127.0.0.1' , new Derived ), 23 ); // WrongVersionException: Multi and IPv4 are different byte lengths. Multi :: factory ( '127.0.0.1' ) -> inRange ( IPv4 :: factory ( '127.0.0.1' ), 23 ); // InvalidCidrException: CIDR above 128. Multi :: factory ( '127.0.0.1' ) -> inRange ( Multi :: factory ( '127.0.0.1' ), 129 );","title":"Examples"},{"location":"04-helpers.html#method-reference","text":"","title":"Method Reference"},{"location":"04-helpers.html#network-ip","text":"@throws \\Darsyn\\IP\\Exception\\InvalidCidrException getNetworkIp(int $cidr): IpInterface <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '12.34.56.78' ); // Get the network address of an IP address given a subnet mask. $networkIp = $ip -> getNetworkIp ( 19 ); $networkIp -> getProtocolAppropriateAddress (); // string(\"12.34.32.0\")","title":"Network IP"},{"location":"04-helpers.html#broadcast-ip","text":"@throws \\Darsyn\\IP\\Exception\\InvalidCidrException getBroadcastIp(int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '12.34.56.78' ); // Get the broadcast address of an IP address given a subnet mask. $broadcastIp = $ip -> getBroadcastIp ( 19 ); $broadcastIp -> getProtocolAppropriateAddress (); // string(\"12.34.63.255\")","title":"Broadcast IP"},{"location":"04-helpers.html#is-ip-in-range","text":"@throws \\Darsyn\\IP\\Exception\\WrongVersionException @throws \\Darsyn\\IP\\Exception\\InvalidCidrException inRange(IpInterface $ip, int $cidr): bool <?php use Darsyn\\IP\\Version\\Multi as IP ; $hostIp = IP :: factory ( ':ffff:c22:384e' ); $clientIp = IP :: factory ( '12.48.183.1' ); $clientIp -> inRange ( $hostIp , 11 ); // bool(true) $clientIp -> inRange ( $hostIp , 24 ); // bool(false)","title":"Is IP in Range?"},{"location":"04-helpers.html#greatest-common-cidr","text":"@throws \\Darsyn\\IP\\Exception\\WrongVersionException getCommonCidr(IpInterface $ip): int <?php use Darsyn\\IP\\Version\\Multi as IP ; $hostIp = IP :: factory ( 'd6be:583:71a4:aa6d:c77d:77dd:cec:f897' ); $clientIp = IP :: factory ( 'd6be:583:71a4:aa67:b07a::c7' ); $hostIp -> getCommonCidr ( $clientIp ); // int(60)","title":"Greatest Common CIDR"},{"location":"04-helpers.html#ipv6-vs-multi","text":"The Multi class tries to deal with both IPv4 and IPv6 interchangeably which can lead to some unexpected results if an IPv6 address is detected as an IPv4-embedded address. Valid CIDR values can be either 0-32 or 0-128 depending on internal state and the embedding strategy used. All the helper methods of Multi are affected by this. The IPv6 class, however, gives consistent results regardless of embedding strategy and always deals with CIDR values from 0 to 128. It is recommended that you pick a concrete version (either IPv4 or IPv6 ) unless you absolutely know that you need to deal with both interchangeably. Using Multi can cause unexpected behaviour. For example, Multi::factory('0.0.0.1', new Strategy\\Compatible) results in an object which is both a loopback address ::1 if viewing as IPv6, but also not a loopback address 127.x.x.x if viewing as an IPv4-embedded address. Use Multi with caution.","title":"IPv6 vs Multi?"},{"location":"04-helpers.html#ipv6-from-embedded","text":"If you want to embed IPv4 addresses into IPv6, but do not want Multi to return varying results depending on whether an IPv4 address is embedded or not, then use IPv6::fromEmbedded() . It accepts both IPv4 and IPv6 addresses, embeds IPv4 addresses into IPv6 according to the embedding strategy, and from that point on treats it purely as an IPv6 address. <?php use Darsyn\\IP\\Strategy\\Mapped ; use Darsyn\\IP\\Version\\Ipv6 ; // Strategy is optional; defaults to Mapped unless // Multi::setDefaultEmbeddingStrategy() called previously. $ip = IPv6 :: fromEmbedded ( '127.0.0.1' , new Mapped ); $ip -> getCompactedAddress (); // string(\"::ffff:7f00:1\") try { $ip -> getDotAddress (); } catch ( \\Error $e ) { // IPv6 addresses are not considered IPv4 addresses and // therefore do not have the method getDotAddress(). } Please note that calling Multi::fromEmbedded() returns an instance of Multi and effectively is the same as calling the factory method.","title":"IPv6 From Embedded"},{"location":"05-strategies.html","text":"Embedding Strategies When using version 4 and version 6 addresses interchangeably (via the Multi class), version 4 addresses are embedded into version 6 addresses so that both versions are stored as 16-byte binary sequences. Unfortunately there are several different strategies for embedding a version 4 address into version 6, so this library offers various strategy implementations for the main three: Strategy Name Implementation Format 6to4-derived Darsyn\\IP\\Strategy\\Derived 2002:XXXX:XXXX:0000:0000:0000:0000:0000 IPv4-compatible Darsyn\\IP\\Strategy\\Compatible 0000:0000:0000:0000:0000:0000:XXXX:XXXX IPv4-mapped Darsyn\\IP\\Strategy\\Mapped 0000:0000:0000:0000:0000:ffff:XXXX:XXXX Each embedding strategy implements the Darsyn\\IP\\Strategy\\EmbeddingStrategyInterface which defines methods to: Detect whether a version 4 address is embedded into a version 6 address, Extracting a version 4 address from a version 6 address, and Packing a version 4 address into a version 6 address according to the given strategy. Specifying a Strategy This library will automatically use the IPv4-mapped embedding strategy unless otherwise instructed. An embedding strategy can be specified globally or on a per-instance basis. <?php use Darsyn\\IP\\Strategy ; use Darsyn\\IP\\Version\\Multi as IP ; // Set the IPv4-compatible embedding strategy to be used globally. IP :: setDefaultEmbeddingStrategy ( new Strategy\\Compatible ); // But for this specific instance use the 6to4-derived embedding strategy. $ip = IP :: factory ( '127.0.0.1' , new Strategy\\Derived );","title":"Embedding Strategies"},{"location":"05-strategies.html#embedding-strategies","text":"When using version 4 and version 6 addresses interchangeably (via the Multi class), version 4 addresses are embedded into version 6 addresses so that both versions are stored as 16-byte binary sequences. Unfortunately there are several different strategies for embedding a version 4 address into version 6, so this library offers various strategy implementations for the main three: Strategy Name Implementation Format 6to4-derived Darsyn\\IP\\Strategy\\Derived 2002:XXXX:XXXX:0000:0000:0000:0000:0000 IPv4-compatible Darsyn\\IP\\Strategy\\Compatible 0000:0000:0000:0000:0000:0000:XXXX:XXXX IPv4-mapped Darsyn\\IP\\Strategy\\Mapped 0000:0000:0000:0000:0000:ffff:XXXX:XXXX Each embedding strategy implements the Darsyn\\IP\\Strategy\\EmbeddingStrategyInterface which defines methods to: Detect whether a version 4 address is embedded into a version 6 address, Extracting a version 4 address from a version 6 address, and Packing a version 4 address into a version 6 address according to the given strategy.","title":"Embedding Strategies"},{"location":"05-strategies.html#specifying-a-strategy","text":"This library will automatically use the IPv4-mapped embedding strategy unless otherwise instructed. An embedding strategy can be specified globally or on a per-instance basis. <?php use Darsyn\\IP\\Strategy ; use Darsyn\\IP\\Version\\Multi as IP ; // Set the IPv4-compatible embedding strategy to be used globally. IP :: setDefaultEmbeddingStrategy ( new Strategy\\Compatible ); // But for this specific instance use the 6to4-derived embedding strategy. $ip = IP :: factory ( '127.0.0.1' , new Strategy\\Derived );","title":"Specifying a Strategy"},{"location":"06-formatters.html","text":"Formatters Internally, this library uses the PHP functions inet_pton and inet_ntop . However the inet_ntop function formats some IP addresses in an inconsistent and non-standard way (for example, the IP address ::ffff:c22:384e would be returned as ::ffff:12.34.56.78 when converting its binary representation to human-readable protocol via inet_ntop ). This library provides a pure-PHP implementation called Darsyn\\IP\\Formatter\\ConsistentFormatter to return IP addresses in the correct format, which is used by default. However should you wish to use the native implementation for any reason, you may set the Darsyn\\IP\\Formatter\\NativeFormatter globally: <?php use Darsyn\\IP\\Formatter\\NativeFormatter ; use Darsyn\\IP\\Version\\Multi as IP ; IP :: setProtocolFormatter ( new NativeFormatter ); $ip = IP :: factory ( '::ffff:c22:384e' ); $ip -> getCompactedAddress (); // string(\"::ffff:12.34.56.78\")","title":"Formatters"},{"location":"06-formatters.html#formatters","text":"Internally, this library uses the PHP functions inet_pton and inet_ntop . However the inet_ntop function formats some IP addresses in an inconsistent and non-standard way (for example, the IP address ::ffff:c22:384e would be returned as ::ffff:12.34.56.78 when converting its binary representation to human-readable protocol via inet_ntop ). This library provides a pure-PHP implementation called Darsyn\\IP\\Formatter\\ConsistentFormatter to return IP addresses in the correct format, which is used by default. However should you wish to use the native implementation for any reason, you may set the Darsyn\\IP\\Formatter\\NativeFormatter globally: <?php use Darsyn\\IP\\Formatter\\NativeFormatter ; use Darsyn\\IP\\Version\\Multi as IP ; IP :: setProtocolFormatter ( new NativeFormatter ); $ip = IP :: factory ( '::ffff:c22:384e' ); $ip -> getCompactedAddress (); // string(\"::ffff:12.34.56.78\")","title":"Formatters"},{"location":"07-types.html","text":"Type Methods The type methods return a boolean value depending on whether the IP address is a certain type. Detecting Embedding Strategies Embedded? Whether the IP is an IPv4 address embedded into an IPv6 address, according to the embedding strategy used when creating the IP object. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $ip -> isEmbedded (); // bool(true) If you would like to detect if the IP is an IPv4-embedded IPv6 address, according to RFC 4291 section 2.5.5 , please use the following conditional statement: <?php use Darsyn\\IP\\Strategy\\Derived ; use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' , new Derived ); $rfc4291 = $ip -> isMapped () || $ip -> isCompatible (); // bool(false) Mapped Whether the IP is an IPv4-mapped IPv6 address (eg, ::ffff:7f00:1 ), according to RFC 4291 section 2.5.5.2 . The IPv4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $ip -> isMapped (); // bool(true) Derived Whether the IP is a 6to4-derived IPv6 address (eg, 2002:7f00:1:: ), according to RFC 3056 . The IPv4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '2002:7f00:1::' ); $ip -> isDerived (); // bool(true) Compatible Whether the IP is an IPv4-compatible IPv6 address (eg, ::7f00:1 ), according to RFC 4291 section 2.5.5.1 . The IPv4 class will always return bool(false) for this method. IPv4-compatible IPv6 addresses are deprecated in the RFC. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::7f00:1' ); $ip -> isCompatible (); // bool(true) Detecting Address Types Link Local Whether the IP is reserved for link-local usage, according to RFC 3927 (IPv4) or RFC 4291 section 2.4 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isLinkLocal (); // bool(false) Loopback Whether the IP is a loopback address, according to RFC 1122 section 3.2.1.3 (IPv4) or RFC 4291 section 2.5.3 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isLoopback (); // bool(true) Multicast Whether the IP is a multicast address, according to RFC 5771 (IPv4) or RFC 4291 section 2.7 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isMulticast (); // bool(false) Private Use Whether the IP is for private use, according to RFC 1918 section 3 (IPv4) or RFC 4193 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isPrivateUse (); // bool(false) Unspecified Whether the IP is unspecified, according to RFC 5735 (IPv4) or RFC 2373 section 2.5.2 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isUnspecified (); // bool(false) Benchmarking Whether the IP is reserved for network devices benchmarking, according to RFC 2544 corrected in errata 423 (IPv4) or RFC 5180 corrected in errata 1752 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isBenchmarking (); // bool(false) Documentation Whether the IP is in range designated for documentation, according to RFC 5737 (IPv4) or RFC 3849 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isDocumentation (); // bool(false) Public Use (Global) Whether the IP appears to be publicly/globally routable (please refer to the following: IANA IPv4 Special-Purpose Address Registry IANA IPv6 Special-Purpose Address Registry <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isPublicUse (); // bool(false) IPv4 Specific These methods will throw a WrongVersionException if called from Multi on an IPv6 address (non IPv4-embedded). Broadcast Whether the IP is a broadcast address, according to RFC 919 . <?php use Darsyn\\IP\\Version\\IPv4 ; IPv4 :: factory ( '127.0.0.1' ) -> isBroadcast (); // bool(false) IPv4 :: factory ( '255.255.255.255' ) -> isBroadcast (); // bool(true) Reserved for Future Use Whether the IP is reserved for future use, according to RFC 1112 . <?php use Darsyn\\IP\\Version\\IPv4 ; IPv4 :: factory ( '127.0.0.1' ) -> isFutureReserved (); // bool(false) IPv4 :: factory ( '255.34.85.169' ) -> isFutureReserved (); // bool(true) Shared Whether the IP is part of the Shared Address Space, according to RFC 6598 . <?php use Darsyn\\IP\\Version\\IPv4 ; IPv4 :: factory ( '100.128.179.30' ) -> isShared (); // bool(false) IPv4 :: factory ( '100.127.43.2' ) -> isShared (); // bool(true) IPv6 Specific Multicast Scope The specific scope of the multicast address (returns null if not a multicast address). The following constants are available on Darsyn\\IP\\Version\\Version6Interface : MULTICAST_INTERFACE_LOCAL MULTICAST_LINK_LOCAL MULTICAST_REALM_LOCAL MULTICAST_ADMIN_LOCAL MULTICAST_SITE_LOCAL MULTICAST_ORGANIZATION_LOCAL MULTICAST_GLOBAL <?php use Darsyn\\IP\\Version\\IPv6 ; $isOrganizationLocal = IPv6 :: factory ( 'ff08:1:6e6f:cbb::980e:3816' ) -> getMulticastScope () === IPv6 :: MULTICAST_ORGANIZATION_LOCAL ; // bool(true) Unique Local Whether the IP is a unique local address, according to RFC 4193 . <?php use Darsyn\\IP\\Version\\IPv6 ; IPv6 :: factory ( 'b638:cc70:716:c4d4:f69c:4ee3:6c65:a0b2' ) -> isUniqueLocal (); // bool(false) IPv6 :: factory ( 'fdff:ffff::' ) -> isUniqueLocal (); // bool(true) Unicast Whether the IP is a unicast address, according to RFC 4291 (any IPv6 address that is not a multicast address is unicast, and vice-versa). <?php use Darsyn\\IP\\Version\\IPv6 ; IPv6 :: factory ( 'ff08::' ) -> isUnicast (); // bool(false) IPv6 :: factory ( '::ffff:1:0' ) -> isUnicast (); // bool(true) Unicast Global Whether the IP is a globally routable unicast address, according to RFC 4291 section 2.5.4 . <?php use Darsyn\\IP\\Version\\IPv6 ; IPv6 :: factory ( '2001:db8:85a3::8a2e:370:7334' ) -> isUnicastGlobal (); // bool(false) IPv6 :: factory ( '140c:12f1:6e6f:c0bb:980e:3816:3e52:1193' ) -> isUnicastGlobal (); // bool(true)","title":"Type Methods"},{"location":"07-types.html#type-methods","text":"The type methods return a boolean value depending on whether the IP address is a certain type.","title":"Type Methods"},{"location":"07-types.html#detecting-embedding-strategies","text":"","title":"Detecting Embedding Strategies"},{"location":"07-types.html#embedded","text":"Whether the IP is an IPv4 address embedded into an IPv6 address, according to the embedding strategy used when creating the IP object. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $ip -> isEmbedded (); // bool(true) If you would like to detect if the IP is an IPv4-embedded IPv6 address, according to RFC 4291 section 2.5.5 , please use the following conditional statement: <?php use Darsyn\\IP\\Strategy\\Derived ; use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' , new Derived ); $rfc4291 = $ip -> isMapped () || $ip -> isCompatible (); // bool(false)","title":"Embedded?"},{"location":"07-types.html#mapped","text":"Whether the IP is an IPv4-mapped IPv6 address (eg, ::ffff:7f00:1 ), according to RFC 4291 section 2.5.5.2 . The IPv4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::ffff:7f00:1' ); $ip -> isMapped (); // bool(true)","title":"Mapped"},{"location":"07-types.html#derived","text":"Whether the IP is a 6to4-derived IPv6 address (eg, 2002:7f00:1:: ), according to RFC 3056 . The IPv4 class will always return bool(false) for this method. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '2002:7f00:1::' ); $ip -> isDerived (); // bool(true)","title":"Derived"},{"location":"07-types.html#compatible","text":"Whether the IP is an IPv4-compatible IPv6 address (eg, ::7f00:1 ), according to RFC 4291 section 2.5.5.1 . The IPv4 class will always return bool(false) for this method. IPv4-compatible IPv6 addresses are deprecated in the RFC. <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '::7f00:1' ); $ip -> isCompatible (); // bool(true)","title":"Compatible"},{"location":"07-types.html#detecting-address-types","text":"","title":"Detecting Address Types"},{"location":"07-types.html#link-local","text":"Whether the IP is reserved for link-local usage, according to RFC 3927 (IPv4) or RFC 4291 section 2.4 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isLinkLocal (); // bool(false)","title":"Link Local"},{"location":"07-types.html#loopback","text":"Whether the IP is a loopback address, according to RFC 1122 section 3.2.1.3 (IPv4) or RFC 4291 section 2.5.3 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isLoopback (); // bool(true)","title":"Loopback"},{"location":"07-types.html#multicast","text":"Whether the IP is a multicast address, according to RFC 5771 (IPv4) or RFC 4291 section 2.7 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isMulticast (); // bool(false)","title":"Multicast"},{"location":"07-types.html#private-use","text":"Whether the IP is for private use, according to RFC 1918 section 3 (IPv4) or RFC 4193 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isPrivateUse (); // bool(false)","title":"Private Use"},{"location":"07-types.html#unspecified","text":"Whether the IP is unspecified, according to RFC 5735 (IPv4) or RFC 2373 section 2.5.2 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isUnspecified (); // bool(false)","title":"Unspecified"},{"location":"07-types.html#benchmarking","text":"Whether the IP is reserved for network devices benchmarking, according to RFC 2544 corrected in errata 423 (IPv4) or RFC 5180 corrected in errata 1752 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isBenchmarking (); // bool(false)","title":"Benchmarking"},{"location":"07-types.html#documentation","text":"Whether the IP is in range designated for documentation, according to RFC 5737 (IPv4) or RFC 3849 (IPv6). <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isDocumentation (); // bool(false)","title":"Documentation"},{"location":"07-types.html#public-use-global","text":"Whether the IP appears to be publicly/globally routable (please refer to the following: IANA IPv4 Special-Purpose Address Registry IANA IPv6 Special-Purpose Address Registry <?php use Darsyn\\IP\\Version\\Multi as IP ; $ip = IP :: factory ( '127.0.0.1' ); $ip -> isPublicUse (); // bool(false)","title":"Public Use (Global)"},{"location":"07-types.html#ipv4-specific","text":"These methods will throw a WrongVersionException if called from Multi on an IPv6 address (non IPv4-embedded).","title":"IPv4 Specific"},{"location":"07-types.html#broadcast","text":"Whether the IP is a broadcast address, according to RFC 919 . <?php use Darsyn\\IP\\Version\\IPv4 ; IPv4 :: factory ( '127.0.0.1' ) -> isBroadcast (); // bool(false) IPv4 :: factory ( '255.255.255.255' ) -> isBroadcast (); // bool(true)","title":"Broadcast"},{"location":"07-types.html#reserved-for-future-use","text":"Whether the IP is reserved for future use, according to RFC 1112 . <?php use Darsyn\\IP\\Version\\IPv4 ; IPv4 :: factory ( '127.0.0.1' ) -> isFutureReserved (); // bool(false) IPv4 :: factory ( '255.34.85.169' ) -> isFutureReserved (); // bool(true)","title":"Reserved for Future Use"},{"location":"07-types.html#shared","text":"Whether the IP is part of the Shared Address Space, according to RFC 6598 . <?php use Darsyn\\IP\\Version\\IPv4 ; IPv4 :: factory ( '100.128.179.30' ) -> isShared (); // bool(false) IPv4 :: factory ( '100.127.43.2' ) -> isShared (); // bool(true)","title":"Shared"},{"location":"07-types.html#ipv6-specific","text":"","title":"IPv6 Specific"},{"location":"07-types.html#multicast-scope","text":"The specific scope of the multicast address (returns null if not a multicast address). The following constants are available on Darsyn\\IP\\Version\\Version6Interface : MULTICAST_INTERFACE_LOCAL MULTICAST_LINK_LOCAL MULTICAST_REALM_LOCAL MULTICAST_ADMIN_LOCAL MULTICAST_SITE_LOCAL MULTICAST_ORGANIZATION_LOCAL MULTICAST_GLOBAL <?php use Darsyn\\IP\\Version\\IPv6 ; $isOrganizationLocal = IPv6 :: factory ( 'ff08:1:6e6f:cbb::980e:3816' ) -> getMulticastScope () === IPv6 :: MULTICAST_ORGANIZATION_LOCAL ; // bool(true)","title":"Multicast Scope"},{"location":"07-types.html#unique-local","text":"Whether the IP is a unique local address, according to RFC 4193 . <?php use Darsyn\\IP\\Version\\IPv6 ; IPv6 :: factory ( 'b638:cc70:716:c4d4:f69c:4ee3:6c65:a0b2' ) -> isUniqueLocal (); // bool(false) IPv6 :: factory ( 'fdff:ffff::' ) -> isUniqueLocal (); // bool(true)","title":"Unique Local"},{"location":"07-types.html#unicast","text":"Whether the IP is a unicast address, according to RFC 4291 (any IPv6 address that is not a multicast address is unicast, and vice-versa). <?php use Darsyn\\IP\\Version\\IPv6 ; IPv6 :: factory ( 'ff08::' ) -> isUnicast (); // bool(false) IPv6 :: factory ( '::ffff:1:0' ) -> isUnicast (); // bool(true)","title":"Unicast"},{"location":"07-types.html#unicast-global","text":"Whether the IP is a globally routable unicast address, according to RFC 4291 section 2.5.4 . <?php use Darsyn\\IP\\Version\\IPv6 ; IPv6 :: factory ( '2001:db8:85a3::8a2e:370:7334' ) -> isUnicastGlobal (); // bool(false) IPv6 :: factory ( '140c:12f1:6e6f:c0bb:980e:3816:3e52:1193' ) -> isUnicastGlobal (); // bool(true)","title":"Unicast Global"},{"location":"08-doctrine.html","text":"Doctrine Support This library can be used to support IP address as column types with Doctrine. Three Doctrine types are provided to match the three version classes: Darsyn\\IP\\Doctrine\\IPV4Type supports the IPv4 class. Darsyn\\IP\\Doctrine\\IPV6Type supports the IPv6 class. Darsyn\\IP\\Doctrine\\MultiType supports the Multi class. <?php use Darsyn\\IP\\Doctrine\\MultiType ; use Doctrine\\DBAL\\Types\\Type ; Type :: addType ( 'ip' , MultiType :: class ); If you are using Symfony , then add the following to your main configuration: doctrine : dbal : types : ip : Darsyn\\IP\\Doctrine\\MultiType Now you can happily store IP addresses in your entities like nobody's business: <?php use Darsyn\\IP\\Version\\Multi as IP ; use Doctrine\\ORM\\Mapping as ORM ; #[ORM\\Entity] class AnalyticsEntity { #[ORM\\Column(type: 'ip')] public IP $ipAddress ; }","title":"Doctrine Support"},{"location":"08-doctrine.html#doctrine-support","text":"This library can be used to support IP address as column types with Doctrine. Three Doctrine types are provided to match the three version classes: Darsyn\\IP\\Doctrine\\IPV4Type supports the IPv4 class. Darsyn\\IP\\Doctrine\\IPV6Type supports the IPv6 class. Darsyn\\IP\\Doctrine\\MultiType supports the Multi class. <?php use Darsyn\\IP\\Doctrine\\MultiType ; use Doctrine\\DBAL\\Types\\Type ; Type :: addType ( 'ip' , MultiType :: class ); If you are using Symfony , then add the following to your main configuration: doctrine : dbal : types : ip : Darsyn\\IP\\Doctrine\\MultiType Now you can happily store IP addresses in your entities like nobody's business: <?php use Darsyn\\IP\\Version\\Multi as IP ; use Doctrine\\ORM\\Mapping as ORM ; #[ORM\\Entity] class AnalyticsEntity { #[ORM\\Column(type: 'ip')] public IP $ipAddress ; }","title":"Doctrine Support"},{"location":"09-utilities.html","text":"Utilities Binary Utility The IP value objects store their internal state as a binary string, which is not easy for humans to understand. The Darsyn\\IP\\Util\\Binary class is a collection of static helper methods for dealing with such binary strings. From Hexadecimal @throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::fromHex(string $hex): string Because there are two hexadecimal characters per byte, the input string must be of a length that is a multiple of 2. <?php use Darsyn\\IP\\Util\\Binary ; $hexString = '48656c6c6f21' ; Binary :: fromHex ( $hexString ); // string(\"Hello!\") To Hexadecimal @throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::toHex(string $hex): string <?php use Darsyn\\IP\\Util\\Binary ; $binaryString = 'Hello!' ; Binary :: toHex ( $binaryString ); // string(\"48656c6c6f21\") From Human-readable Binary @throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::fromHumanReadable(string $asciiBinarySequence): string Because there are 8 bits per bytes, the input string must be of a length that is a multiple of 8. <?php use Darsyn\\IP\\Util\\Binary ; $asciiBinary = '010010000110010101101100011011000110111100100001' ; Binary :: fromHumanReadable ( $asciiBinary ); // string(\"Hello!\") To Human-readable @throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::toHumanReadable(string $binary): string <?php use Darsyn\\IP\\Util\\Binary ; $binaryString = 'Hello!' ; Binary :: toHumanReadable ( $asciiBinary ); // string(\"010010000110010101101100011011000110111100100001\") Multibyte String Utility On some PHP installations, the Multibyte String extension can overload PHP's native string functions which, because we are working with arbitrary binary content, can incorrectly guess an encoding when attempting to transform this data (IP addresses have no text encoding). Because of this, the Darsyn\\IP\\Util\\MbString class is a collection of static helper equivalents for PHP's core string functions which detect if the mbstring extension is installed and appropriately call the correct function, specifying the 8bit text encoding (treat each byte as individual character) if required. Static Helper Method Replaces the PHP function... MbString::getLength() str_len() MbString::subString() substr() MbString::padString() str_pad()","title":"Utilities"},{"location":"09-utilities.html#utilities","text":"","title":"Utilities"},{"location":"09-utilities.html#binary-utility","text":"The IP value objects store their internal state as a binary string, which is not easy for humans to understand. The Darsyn\\IP\\Util\\Binary class is a collection of static helper methods for dealing with such binary strings.","title":"Binary Utility"},{"location":"09-utilities.html#from-hexadecimal","text":"@throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::fromHex(string $hex): string Because there are two hexadecimal characters per byte, the input string must be of a length that is a multiple of 2. <?php use Darsyn\\IP\\Util\\Binary ; $hexString = '48656c6c6f21' ; Binary :: fromHex ( $hexString ); // string(\"Hello!\")","title":"From Hexadecimal"},{"location":"09-utilities.html#to-hexadecimal","text":"@throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::toHex(string $hex): string <?php use Darsyn\\IP\\Util\\Binary ; $binaryString = 'Hello!' ; Binary :: toHex ( $binaryString ); // string(\"48656c6c6f21\")","title":"To Hexadecimal"},{"location":"09-utilities.html#from-human-readable-binary","text":"@throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::fromHumanReadable(string $asciiBinarySequence): string Because there are 8 bits per bytes, the input string must be of a length that is a multiple of 8. <?php use Darsyn\\IP\\Util\\Binary ; $asciiBinary = '010010000110010101101100011011000110111100100001' ; Binary :: fromHumanReadable ( $asciiBinary ); // string(\"Hello!\")","title":"From Human-readable Binary"},{"location":"09-utilities.html#to-human-readable","text":"@throws \\InvalidArgumentException \\Darsyn\\IP\\Util\\Binary::toHumanReadable(string $binary): string <?php use Darsyn\\IP\\Util\\Binary ; $binaryString = 'Hello!' ; Binary :: toHumanReadable ( $asciiBinary ); // string(\"010010000110010101101100011011000110111100100001\")","title":"To Human-readable"},{"location":"09-utilities.html#multibyte-string-utility","text":"On some PHP installations, the Multibyte String extension can overload PHP's native string functions which, because we are working with arbitrary binary content, can incorrectly guess an encoding when attempting to transform this data (IP addresses have no text encoding). Because of this, the Darsyn\\IP\\Util\\MbString class is a collection of static helper equivalents for PHP's core string functions which detect if the mbstring extension is installed and appropriately call the correct function, specifying the 8bit text encoding (treat each byte as individual character) if required. Static Helper Method Replaces the PHP function... MbString::getLength() str_len() MbString::subString() substr() MbString::padString() str_pad()","title":"Multibyte String Utility"},{"location":"10-api.html","text":"API Reference Method Returns IPv4 IPv6 Multi factory(string $ip, [$strategy]) Static IpInterface \u2713 \u2713 \u2713 getBinary() string \u2713 \u2713 \u2713 equals(IpInterface $ip) bool \u2713 \u2713 \u2713 getVersion() int \u2713 \u2713 \u2713 isVersion(int $version) bool \u2713 \u2713 \u2713 isVersion4() bool \u2713 \u2713 \u2713 isVersion6() bool \u2713 \u2713 \u2713 getNetworkIp(int $cidr) Static IpInterface \u2713 \u2713 \u2713 getBroadcastIp(int $cidr) Static IpInterface \u2713 \u2713 \u2713 inRange(IpInterface $ip, int $cidr) bool \u2713 \u2713 \u2713 getCommonCidr(IpInterface $ip) int \u2713 \u2713 \u2713 isMapped() bool \u2713 \u2713 \u2713 isDerived() bool \u2713 \u2713 \u2713 isCompatible() bool \u2713 \u2713 \u2713 isEmbedded() bool \u2713 \u2713 \u2713 isLinkLocal() bool \u2713 \u2713 \u2713 isLoopback() bool \u2713 \u2713 \u2713 isMulticast() bool \u2713 \u2713 \u2713 isPrivateUse() bool \u2713 \u2713 \u2713 isUnspecified() bool \u2713 \u2713 \u2713 isBenchmarking() bool \u2713 \u2713 \u2713 isDocumentation() bool \u2713 \u2713 \u2713 isPublicUse() bool \u2713 \u2713 \u2713 isBroadcast() bool \u2713 \u2713 isShared() bool \u2713 \u2713 isFutureReserved() bool \u2713 \u2713 getDotAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getExpandedAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getMulticastScope() ?int \u2713 \u2713 isUniqueLocal() bool \u2713 \u2713 isUnicast() bool \u2713 \u2713 isUnicastGlobal() bool \u2713 \u2713 getProtocolAppropriateAddress() string \u2713","title":"API Reference"},{"location":"10-api.html#api-reference","text":"Method Returns IPv4 IPv6 Multi factory(string $ip, [$strategy]) Static IpInterface \u2713 \u2713 \u2713 getBinary() string \u2713 \u2713 \u2713 equals(IpInterface $ip) bool \u2713 \u2713 \u2713 getVersion() int \u2713 \u2713 \u2713 isVersion(int $version) bool \u2713 \u2713 \u2713 isVersion4() bool \u2713 \u2713 \u2713 isVersion6() bool \u2713 \u2713 \u2713 getNetworkIp(int $cidr) Static IpInterface \u2713 \u2713 \u2713 getBroadcastIp(int $cidr) Static IpInterface \u2713 \u2713 \u2713 inRange(IpInterface $ip, int $cidr) bool \u2713 \u2713 \u2713 getCommonCidr(IpInterface $ip) int \u2713 \u2713 \u2713 isMapped() bool \u2713 \u2713 \u2713 isDerived() bool \u2713 \u2713 \u2713 isCompatible() bool \u2713 \u2713 \u2713 isEmbedded() bool \u2713 \u2713 \u2713 isLinkLocal() bool \u2713 \u2713 \u2713 isLoopback() bool \u2713 \u2713 \u2713 isMulticast() bool \u2713 \u2713 \u2713 isPrivateUse() bool \u2713 \u2713 \u2713 isUnspecified() bool \u2713 \u2713 \u2713 isBenchmarking() bool \u2713 \u2713 \u2713 isDocumentation() bool \u2713 \u2713 \u2713 isPublicUse() bool \u2713 \u2713 \u2713 isBroadcast() bool \u2713 \u2713 isShared() bool \u2713 \u2713 isFutureReserved() bool \u2713 \u2713 getDotAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getExpandedAddress() string \u2713 \u2713 getCompactedAddress() string \u2713 \u2713 getMulticastScope() ?int \u2713 \u2713 isUniqueLocal() bool \u2713 \u2713 isUnicast() bool \u2713 \u2713 isUnicastGlobal() bool \u2713 \u2713 getProtocolAppropriateAddress() string \u2713","title":"API Reference"}]}